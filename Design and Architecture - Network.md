# 第二章 网络

本章讲述了Swarm是如何在对等网络协议之上构建覆盖网络的。这个覆盖网络形成一个拓扑结构，从而使得节点之间可以相互路由消息（第2.1节）。在第2.2章中，我们描述Swarm这样一个网络是如何成为数据块的可伸缩分布式存储解决方案（第2.2.1节），并给出了Swarm支持检索（下载）和同步（上传）协议的逻辑（2.3）。

## 2.1 拓扑和路由

本节通过明确底层网络（underlay network，第1层）的假设，从而为Swarm的覆盖网络（overlay network ，第2层）建立使用场景（第2.1.1节）。第2.1.2节介绍了覆盖网络的地址空间，并解释了如何为Swarm节点分配这些地址。在第2.1.3节中，我们展示了Kademlia覆盖拓扑（连接模式），并解释了Kademlia如何解决节点之间的路由问题。在2.1.4中，我们展示了如何运行Swarm客户端节点，以及客户端节点如何启动、如何相互发现，从而维护覆盖网络的拓扑结构。

#### 2.1.1 对底层网络的需求

Swarm是一个由用户直接操作的网络。网络中的每个节点都应该运行一个符合协议规范的客户端。在最低层网络中，网络中的节点连接使用对等网络协议作为传输层。这就是所谓的底层网络（underlay network）。在总体设计中，只要底层网络满足以下要求，特定的传输实现对Swarm来说是不可知的。
1. 寻址——节点由其底层地址标识。
2. 拨号——节点可以通过拨号底层地址发起到对等节点的直接连接。
3. 侦听——节点可以侦听其他节点的拨号，并可以接受传入的连接。不接受传入连接的节点称为轻节点。
4. 实时连接——节点之间的连接建立了一个通信通道，该通道在显式断开连接之前一直保持活跃，因此连接的存在意味着远端对等节点一直在线并可以接受消息。
5. 通道安全——通道提供身份验证，实现加密和认证传输，抵御中间人攻击。
6. 协议多路复用——底层网络服务可支持在同一连接上运行多个协议。对等节点用它们自己实现的名称和版本来建立协议，底层网络服务对兼容的协议进行标识，并在每个匹配的协议上启动对等节点之间的连接。
7. 交付保证——协议对消息有交付保证，即由于网络问题导致的交付失败将立即返回失败。另外，每个协议内部都保证了消息传递的顺序。理想情况下，底层协议提供了消息传递的优先级。如果在同一个传输通道上实现协议多路复用，这很可能意味着消息会被分帧，这样长消息就不会阻塞优先级更高的消息。
8. 序列化——协议中的消息构造支持任意的数据结构序列化约定。

libp2p库可以提供上述所有需要的功能，并且在Swarm规范中作为底层网络的连接驱动器给出，参见第8.1.1节。

注：Swarm目前的golang实现使用以太坊的Devp2p/rlpx，可以满足上述需求，并使用TCP/IP与自定义加密增加了安全功能。Devp2p底层网络地址使用enode URL方案。Devp2p基于协议的消息ID来分发消息。它使用RLP序列化，这种序列化使用更高级别的数据类型表示约定进行了扩展。为了支持以太坊1.0及其状态，我们可以提供一个瘦的devp2p节点作为代理，将查询转发给基于libp2p的Swarm客户端，或者仅仅使用libp2p客户端的API。不过，我们预计对devp2p网络的支持即将停止。

#### 2.1.2 覆盖网络寻址

当客户端使用底层地址与对等节点建立连接时，每个运行Swarm的节点都被附加一个覆盖地址标识。正是这个地址决定了一个节点将连接到哪个对等节点，并决定了消息转发的方式。覆盖地址被认为是稳定的，因为它定义了跨会话的节点标识，并最终影响哪些内容最值得存储在节点的本地存储中。

通过使用256位Keccak算法（见第7.2节）将相应的椭圆曲线公钥与bzz网络ID散列，节点的覆盖地址是从以太坊账户派生出来。包含BZZ网络ID的原因是可能存在许多Swarm网络（例如测试网、主网或私有Swarm网络）。如果包含BZZ网络ID，就不可能跨网络使用相同的地址。假设任何独立选择的基本帐户样本，所得到的覆盖地址都将在256位整数的地址空间中具有均匀分布。这对于从公钥中获取地址很重要，因为它允许节点使用可由第三方验证的加密签名发布与覆盖位置相关的承诺。

群节点利用底层网络的长寿命通信通道，形成一个准永久对等连接的网络。由此产生的连通性图可以实现在地址空间上定义的特定拓扑。选择的覆盖拓扑称为Kademlia：它通过提供一种只使用底层对等连接中继消息的策略，使Swarm网络中任意两个节点之间的通信成为可能。第8.3节中描述了一个名为“Hive”的协议，该协议描述了节点之间如何共享关于自己和其他节点的信息。节点如何使用该协议来引导覆盖拓扑将在2.1.4中讨论。Kademlia拓扑学的理论基础在文章《》中被严格形式化。

最重要的是，覆盖地址空间都是256位整数。蜂群的中心是接近顺序（proximity order,PO）的概念，它量化了两个地址在离散尺度上的相关性给定两个地址x和y, PO(x, y)对其二进制表示中的匹配位进行计数，从最高有效位开始，直到第一个不同的位为止。因此，最高的接近顺序为256，表示最大的亲缘关系，即x = y。

#### 2.1.3 Kademlia 路由

Kademlia拓扑可用于使用覆盖寻址在网络节点之间路由消息。它具有优秀的可伸缩性，因为它允许通用路由，这样(1)跳数和(2)对等连接的数量总是对网络规模的对数。
接下来，我们将介绍两种常见的路由:迭代/缩放和递归/转发。Swarm的设计关键在于选择后者，即转发风格。然而，这是不寻常的，而且，由于迭代风格在许多对等文献中占主导地位，而大多数其他实现都使用迭代路由(参见[Maymounkov和Mazieres, 2002, Baumgart和Mies, 2007, Lua等人，2005])，我们认为对读者介绍这两种方法是有用的，这样可以揭示它们的特点。

迭代和转发Kademlia
设R是网络节点上任意的二进制关系。与R相对的节点x称为x的对等体。x的对等体可以通过它们相对于x的接近顺序(PO)进行索引(见a .1)。对等体的等价类称为接近顺序箱，或简称箱。一旦被安排在箱子中，这些同伴组就形成了节点x的Kademlia表(见图2)。

#### 2.1.4 节点启动与Kademlia拓扑的维护

图2:从覆盖地址空间到Kademlia表。顶部:覆盖的地址空间用二叉树表示，有颜色的叶子是实际的节点。枢轴节点(+)的路径用粗线表示。中心:枢轴节点的对等点以距枢轴的异或距离的位为键值显示。这里0表示与主元匹配的位，1表示不同的位。叶节点按它们与枢轴(最左边的节点)的异或距离排序。底部:枢轴的Kademlia表:从枢轴路径分支出来的子树在左边显示为表的行，表示接近顺序箱，按递增顺序排列。



## 2.2 Swarm 存储

#### 基于数据块的分布式不可变存储



#### 内容寻址数据块



#### 单个所有者数据块



#### 数据块加密



#### 通过复制实现冗余





## 推和拉：数据块的检索和同步

#### 检索

在分布式数据块存储中，如果消息在请求者和离数据块最近的节点之间可路由（译者注：这里的最近，指的是节点ID和数据块ID之间的距离），则称该数据块为可访问块。向数据块地址发送检索请求，消息将到达此节点。由于最终的一致性，最接近块地址的节点将存储数据块。因此，在一个运行良好的Kademlia拓扑的DISC（ distributed immutable store for chunks）分布式块存储中，所有节点总是可以访问所有数据块。

**数据块交付 **
对于检索，可访问性需要用一个流程来补充，以便将内容交付给请求节点。并且最好是仅仅使用块地址。至少有三种方法可以实现这一点（见图14）：

1. 直接交付：数据块交付通过一个直接的底层连接发送。
2. 路由交付：使用路由将数据块作为消息发送。
3. 反向交付：数据块交付响应简单地遵循请求被转发的路线，只是反向一直到请求发起者。

首先，采用最简单的直接交付方式，通过较低级别的网络协议直接交付数据块。这需要一个专门的连接，以降低隐私安全性为代价来改善延迟。其次，使用路由传递，将数据块通过在发送时从存储者的角度确定的专门路由传递回给它的请求者。无论是直接传递还是路由传递，都允许独立于请求路由进行路由传递，前提是存储者和路由节点（至少部分）知道请求者的地址，因此，这些方法泄漏了请求者的标识信息。然而，对于向后转发的Kademlia拓扑，是不需要知道请求者的拓扑信息的：存储节点对请求的对等节点进行响应，同时中间转发节点记住哪个对等节点请求了哪个数据块。当数据块交付时，它们将它传递回它们的直接请求者，以此类推，直到它最终到达最初请求数据块的节点。换句话说，数据块块交付响应只是按照请求路由返回到发起者（参见图15）。因为这是转发的反向操作，所以我们可以开玩笑地称其为反向交付。Swarm使用了这个选项，可以不公开请求者的身份（任何形式），因此Swarm实现了完全匿名的检索。



图15：backward:转发Kademlia中匿名请求-响应往返的模式。

这里有一个节点覆盖地址…0000…向目标....1111发送请求…最近的在线节点是…1110…前面的省略号表示请求者和目标者共享的前缀，长度为n位，后面的省略号表示与路由无关的部分地址，因为该深度节点已经是唯一的。

请求使用通常的Kademlia转发，但是中继节点记住请求来自的对等端，这样当响应到达时，他们可以沿着相同的路线向后传递(即向后传递)。





检索协议中默认的请求者匿名是Swarm为确保用户隐私和防审查访问而坚持的一个关键特性。
如图16所示，通过反向实现检索的通用解决方案在垃圾邮件保护、扩展和激励方面有进一步的好处，这将在本节的其余部分讨论。



防止未经请求的块
为了记住请求，转发节点需要创建一个资源，为此它需要承担一些成本(它需要占用内存空间)。没有相应交付的请求最终应该被垃圾收集，因此需要有一个确定的活动时间段。还需要通知下游对等体此请求的超时。这是有意义的，因为请求的发起者希望给请求附加一个活动持续时间，以指示它将等待响应的时间。



图16:检索。节点D (Downloader)向块的地址发送一个检索请求。检索使用转发Kademlia，所以请求通过转发节点F0，…从Fn一直到节点S，即最接近块地址的存储节点。然后通过沿着相同的路径返回到下载程序来传递块。



发送未经请求的块是一种违法行为，因为它会导致拒绝服务(DoS)。通过记住一个请求，节点能够识别未经请求的块交付，并惩罚发送它们的节点。在请求到期后交付的块将被视为未请求的。由于节点之间的超时时间评估可能存在一些差异，因此需要对未经请求的块传递有一定的容错性，但如果它们超过了转发的请求的特定百分比(但仍然很小)，那么有问题的对等体将断开连接并被列入黑名单。这种地方制裁是鼓励遵守议定书的最简单和最简单的方法(见3.2.7)。



Rerequesting
有很大一部分的Swarm节点不总是稳定在线的潜力。如此高的生产情况是有问题的,如果我们使用的天真的策略将请求转发给任何一个接近节点:如果路径上的节点离线交付之前完成,然后请求-响应往返坏了,有效地呈现请求的块无法复原。如果与请求的对等体的连接被放弃，那么为块付费的承诺被认为是无效的，所以从另一个节点重新请求块是没有坏处的(见9.2)。

注意，在《Swarm》中并没有关于未被发现的块的明确的负面反应。原则上，离检索到的地址最近的节点可以知道该地址上没有块，因此可以发出“未找到”响应，但由于以下原因，这并不可取。虽然最近的节点块可以验证这一块确实不是在网络中的位置应该是,远离所有节点块不能令人信服地认为这是他们不能验证它直接和积极的证据对块的可回收性获得以后回顾可否认的可信。

总而言之，只要交付能够为存储器创造收益，最好的策略就是保持一个挂起的请求打开，直到超时，并做好准备，以防块出现。有几种方式可以在请求之后到达数据块:(1)从现有的对等点同步(2)出现一个新节点或(3)如果请求在上传之前，例如请求者已经“订阅”了一个单一的所有者地址(见6.3)，以减少检索延迟。这在概念上不同于通常的基于服务器-客户机的体系结构，在这种体系结构中，期望资源在主机服务器上或不在服务器上都是有意义的。



投机取巧的缓存
对块传递响应使用后退来检索请求还允许机会缓存，转发节点接收到块，然后保存块，以防再次请求。这种机制对于确保Swarm自动扩展流行内容的存储和分发至关重要(见3.1.2)。

激励
到目前为止，我们已经证明了通过使用检索协议和保持Kademlia连接，网络中的节点能够检索块。然而，由于转发消耗的是稀缺资源(带宽)，没有提供解释这种带宽使用的能力，网络的可靠性将取决于搭便车和利他行为的比例。为了解决这个问题，在第3节中，我们将概述一个经济激励系统，它与网络中节点的期望行为相一致。当节点运营商采用这些利润最大化策略时，它们会产生对整个网络用户有益的突发行为。

#### 拉同步

在前几节中，我们介绍了如何将维护Kademlia覆盖拓扑的节点网络用作分布式块存储，以及如何使用转发Kademlia路由定义检索块的协议。在讨论检索时，我们假设块位于与其地址最近的节点上。本节描述负责实现这一假设的协议:确保将块上传到任意节点后将其交付到指定的存储单元。
这个网络协议,称为同步推进,类似于块检索:首先,一块是传送到最近的节点块地址作为请求检索通过同样的路线,然后在响应的保管收据传回沿着相同的路径(参见图17)。存储器返回给上传器的保管声明表明块已经到达可以普遍检索的邻近区域。通过跟踪上传的每个组成块的这些响应，上传者可以确保在共享或发布其上传地址之前，他们的上传可以被网络中的任何节点完全检索。将此数据块的推同步计数和接收到的收据作为一个进度条的后端，该进度条可以显示给上传者，以对他们的数据在网络上的成功传播提供积极的反馈(见6.1和10.2.5)。

托管声明由声称离地址最近的节点签署。类似于检索协议中的下载者，上传者的身份也可以保持隐藏，因此转发Kademlia可以实现匿名上传。
另一个相似之处是，为了允许反向响应，节点应该记住哪个对等端发送了特定的块。这一记录应持续较短的时间，因为预计会有监护回应声明。当此期间结束时，记录将被删除。不匹配记录的托管声明被认为是未经请求的，并且只允许与对等端所有推同步流量的一小部分。超过这个容忍阈值将被允许断开连接和列入黑名单(见3.2.7)。
在本节中，我们描述了如何使用转发Kademlia路由和响应后退的网络协议组织块上传的物流。然而，这个解决方案是不完整的，直到它得到一致的激励:遵循这个协议的策略应该被激励，DoS滥用应该被抑制。稍后将在3.3.1和3.1.3中详细讨论这些内容。

#### 推同步

Pull同步协议负责以下两个属性:
•最终的一致性-同步邻居，当拓扑变化，由于流失或新的节点加入。
•最大的资源利用——节点可以从它们的对等节点拉出块来填充它们的剩余存储。

拉同步是以节点为中心的，而不是以块为中心的，也就是说，它确保一个节点的存储在需要的时候被填满，以及在邻近区域内同步块。当两个节点连接时，它们将开始以两种方式同步，以便在每个对等连接上都有双向的块通信。同步的两个方向由独立的流管理(见8.6)。在流的上下文中，流的消费者称为下游对等点或客户端，而提供者称为上游对等点或服务器。
当两个节点连接并进行数据块同步时，上游对等端提供它本地存储在一个数据流中的所有数据块。为了接收到距离下游节点比上游节点更近的块，下游节点可以订阅上游节点在其Kademlia表中属于邻近订单箱的块流。如果对等连接在最近邻深度d内，客户端订阅所有接近顺序为bin d或更大的流。结果是，同事最终会复制属于他们职责范围内的所有区块。
拉同步服务器的行为在流协议中被称为流提供者的行为(参见8.6)。节点通过不断增加的存储计数(称为bin ID)对数据块进行索引，跟踪它们何时在本地存储数据块。对于每个接近顺序箱，上游对等体按照存储时间戳的降序提供流块。由于在每个对等点连接上同步流，一个chunk可以从多个上游对等点同步到下游对等点。为了节省带宽不发送数据块已经同行,流协议实现了往返:发送块之前,上游同行提供一批块确定的地址,而下游反应与声明块批提供他们真正需要的(参见图18)。请注意，下游对等体根据块地址决定它们是否拥有该块。因此，该方法严重依赖于2.2.1中讨论的块完整性假设。



图18:拉同步。节点不断地同步它们最近的邻居。如果它们有空闲容量，它们也会从邻居深度以外的同行中拉出属于较浅垃圾箱的同步块。



在对等连接的上下文中，如果一个客户端已经同步了上游对等端所有的数据块，则称该客户端是同步的。注意，由于磁盘容量的限制，节点必须设置一个值截断，因此“所有块”读起来就像“所有值大于v的块”的简写(v是一个恒定的排名函数，其起源将在3.3.3中讨论)。为了让一个节点保证它们存储所有大于v的chunk，它的所有邻居必须存储所有大于v的chunk。换句话说，同步节点从它们的存储节点中继承这个值的最大值。

如果块是按照存储的顺序同步的，这可能不会导致节点总是拥有最有利可图的(最常被请求的)块。因此，建议根据上游对等点同步最流行的块，并在达到存储容量时完成同步。通过这种方式，节点有限的存储将得到优化。同步和垃圾收集将在3.3.1和3.3.3中进一步讨论，一个整合的客户端策略将在9.6中指定。

为了总结这一节，我们展示了在一个健康的Swarm中如何满足最终一致性的标准。在任何节点的本地存储中找到的块在被同步到它们的存储之后将成为可检索的。这是因为，只要网络中的对等点将块拉得离自己更近，而不是离上游对等点更近，每个块就会传输一条路由，这条路由在push- sync协议中也可以称为有效的转发路径。如果添加了新节点，旧节点退出，邻里关系就会发生变化，但是只要本地冗余足够高，搅动就不能使以前可检索的块不可检索，邻里关系最终会复制它们的内容，冗余就会恢复。考虑一个不太可能发生的事件:一个全新的社区形成了，最初拥有属于该社区内容的节点最终被排除在外，因此这些块暂时不可用。即使在这种情况下，只要有一个节点链在相关的箱子上运行拉同步流，冗余的可检索性最终就会恢复。



#### 轻节点

轻节点的概念是指较差的带宽环境所需要的一种特殊的操作模式，例如低吞吐量网络上的移动设备，或只允许短暂或低容量存储的设备。

一个节点之所以被称为轻节点，是因为它没有完全参与前面提到的常用协议，比如检索、推同步或拉同步。

如果一个节点的带宽环境受到限制，或者以任何方式维持底层连接的能力受到限制，那么它就不能转发符合Kademlia路由规则的消息。这需要与它的对等节点进行通信，这样它们就不会向它传递消息。

由于Swarm中的所有协议都是模块化的，一个节点可以独立地打开或关闭任何协议(取决于容量和收益需求)。例如:一个节点没有可用的存储空间，但有空闲带宽，可以只作为转发节点参与。当然,在关闭协议技术上是可行的,一个节点必须随时考虑到这一事实他/她的同事期待一定程度的服务如果这是广告,不得接受一些服务是关闭和选择不与该节点进行交互。

由于转发可以赚取收入，这些节点可能仍然会被激励接受检索请求。然而,如果光节点Kademlia上面连接距离订单本p(即它们连接到所有仓库保管员在其最近的邻居节点深度d r同行的,至少有一个同行的每个接近订单本从p d),他们可以做广告,所以参与转发。

当他们想要检索或推块时，如果块地址落在接近顺序箱中，没有对等节点的地方，他们可以在另一个箱中选择一个饱和的对等节点。虽然这可能会导致一个虚假的跳（消息目的地到最新对等体的距离不会因为中继而增加），但Kademlia假设路由可以以对数步完成仍然有效。

被宣传为存储/缓存节点的节点应该存储高于某个值的所有块。为了保持一致性，他们需要同步其职责范围内的内容，这就需要他们运行pull-sync协议。这对于有抱负的存储节点也是如此，它们提供可用的存储，并打开拉同步流来填充它们的存储容量。在早期阶段，节点同步到其他完整存储节点是没有意义的。但是，对于它们来说，与其他类似的新节点同步仍然是有用的，特别是当存储节点的带宽达到最大时。

这里的关键是，为了让冗余和跳数发挥作用，不完整的、不饱和的Kademlia表的轻节点不应该被其他节点计算为饱和。

